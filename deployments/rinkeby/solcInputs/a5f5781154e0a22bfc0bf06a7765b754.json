{
  "language": "Solidity",
  "sources": {
    "contracts/connectors/PrimitiveConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Connector\r\n * @author  Primitive\r\n * @notice  Low-level abstract contract for Primitive Connectors to inherit from.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {Context} from \"@openzeppelin/contracts/GSN/Context.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\n// Primitive\r\nimport {CoreLib, IOption} from \"../libraries/CoreLib.sol\";\r\nimport {\r\n    IPrimitiveConnector,\r\n    IPrimitiveRouter,\r\n    IWETH\r\n} from \"../interfaces/IPrimitiveConnector.sol\";\r\n\r\nabstract contract PrimitiveConnector is IPrimitiveConnector, Context {\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\r\n\r\n    IWETH internal _weth; // Canonical WETH9\r\n    IPrimitiveRouter internal _primitiveRouter; // The PrimitiveRouter contract which executes calls.\r\n    mapping(address => mapping(address => bool)) internal _approved; // Stores approvals for future checks.\r\n\r\n    // ===== Constructor =====\r\n\r\n    constructor(address weth_, address primitiveRouter_) public {\r\n        _weth = IWETH(weth_);\r\n        _primitiveRouter = IPrimitiveRouter(primitiveRouter_);\r\n        checkApproval(weth_, primitiveRouter_); // Approves this contract's weth to be spent by router.\r\n    }\r\n\r\n    /**\r\n     * @notice  Reverts if the `option` is not registered in the PrimitiveRouter contract.\r\n     * @dev     Any `option` which is deployed from the Primitive Registry can be registered with the Router.\r\n     * @param   option The Primitive Option to check if registered.\r\n     */\r\n    modifier onlyRegistered(IOption option) {\r\n        require(\r\n            _primitiveRouter.getRegisteredOption(address(option)),\r\n            \"PrimitiveSwaps: EVIL_OPTION\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ===== External =====\r\n\r\n    /**\r\n     * @notice  Approves the `spender` to pull `token` from this contract.\r\n     * @dev     This contract does not hold funds, infinite approvals cannot be exploited for profit.\r\n     * @param   token The token to approve spending for.\r\n     * @param   spender The address to allow to spend `token`.\r\n     */\r\n    function checkApproval(address token, address spender)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        if (!_approved[token][spender]) {\r\n            IERC20(token).safeApprove(spender, uint256(-1));\r\n            _approved[token][spender] = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // ===== Internal =====\r\n\r\n    /**\r\n     * @notice  Deposits `msg.value` into the Weth contract for Weth tokens.\r\n     * @return  Whether or not ether was deposited into Weth.\r\n     */\r\n    function _depositETH() internal returns (bool) {\r\n        if (msg.value > 0) {\r\n            _weth.deposit.value(msg.value)();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice  Uses this contract's balance of Weth to withdraw Ether and send it to `getCaller()`.\r\n     */\r\n    function _withdrawETH() internal returns (bool) {\r\n        uint256 quantity = IERC20(address(_weth)).balanceOf(address(this));\r\n        if (quantity > 0) {\r\n            // Withdraw ethers with weth.\r\n            _weth.withdraw(quantity);\r\n            // Send ether.\r\n            (bool success, ) = getCaller().call.value(quantity)(\"\");\r\n            // Revert is call is unsuccessful.\r\n            require(success, \"Connector: ERR_SENDING_ETHER\");\r\n            return success;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Calls the Router to pull `token` from the getCaller() and send them to this contract.\r\n     * @dev     This eliminates the need for users to approve the Router and each connector.\r\n     * @param   token The token to pull from `getCaller()` into this contract.\r\n     * @param   quantity The amount of `token` to pull into this contract.\r\n     * @return  Whether or not the `token` was transferred into this contract.\r\n     */\r\n    function _transferFromCaller(address token, uint256 quantity)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (quantity > 0) {\r\n            _primitiveRouter.transferFromCaller(token, quantity);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice  Pushes this contract's balance of `token` to `getCaller()`.\r\n     * @dev     getCaller() is the original `msg.sender` of the Router's `execute` fn.\r\n     * @param   token The token to transfer to `getCaller()`.\r\n     * @return  Whether or not the `token` was transferred to `getCaller()`.\r\n     */\r\n    function _transferToCaller(address token) internal returns (bool) {\r\n        uint256 quantity = IERC20(token).balanceOf(address(this));\r\n        if (quantity > 0) {\r\n            IERC20(token).safeTransfer(getCaller(), quantity);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice  Calls the Router to pull `token` from the getCaller() and send them to this contract.\r\n     * @dev     This eliminates the need for users to approve the Router and each connector.\r\n     * @param   token The token to pull from `getCaller()`.\r\n     * @param   quantity The amount of `token` to pull.\r\n     * @param   receiver The `to` address to send `quantity` of `token` to.\r\n     * @return  Whether or not `token` was transferred to `receiver`.\r\n     */\r\n    function _transferFromCallerToReceiver(\r\n        address token,\r\n        uint256 quantity,\r\n        address receiver\r\n    ) internal returns (bool) {\r\n        if (quantity > 0) {\r\n            _primitiveRouter.transferFromCallerToReceiver(token, quantity, receiver);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice  Uses this contract's balance of underlyingTokens to mint optionTokens to this contract.\r\n     * @param   optionToken The Primitive Option to mint.\r\n     * @return  (uint, uint) (longOptions, shortOptions)\r\n     */\r\n    function _mintOptions(IOption optionToken) internal returns (uint256, uint256) {\r\n        address underlying = optionToken.getUnderlyingTokenAddress();\r\n        _transferBalanceToReceiver(underlying, address(optionToken)); // Sends to option contract\r\n        return optionToken.mintOptions(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice  Uses this contract's balance of underlyingTokens to mint optionTokens to `receiver`.\r\n     * @param   optionToken The Primitive Option to mint.\r\n     * @param   receiver The address that will received the minted long and short optionTokens.\r\n     * @return  (uint, uint) Returns the (long, short) option tokens minted\r\n     */\r\n    function _mintOptionsToReceiver(IOption optionToken, address receiver)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {\r\n        address underlying = optionToken.getUnderlyingTokenAddress();\r\n        _transferBalanceToReceiver(underlying, address(optionToken)); // Sends to option contract\r\n        return optionToken.mintOptions(receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice  Pulls underlying tokens from `getCaller()` to option contract, then invokes mintOptions().\r\n     * @param   optionToken The option token to mint.\r\n     * @param   quantity The amount of option tokens to mint.\r\n     * @return  (uint, uint) Returns the (long, short) option tokens minted\r\n     */\r\n    function _mintOptionsFromCaller(IOption optionToken, uint256 quantity)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {\r\n        require(quantity > 0, \"ERR_ZERO\");\r\n        _transferFromCallerToReceiver(\r\n            optionToken.getUnderlyingTokenAddress(),\r\n            quantity,\r\n            address(optionToken)\r\n        );\r\n        return optionToken.mintOptions(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice  Multi-step operation to close options.\r\n     *          1. Transfer balanceOf `redeem` option token to the option contract.\r\n     *          2. If NOT expired, pull `option` tokens from `getCaller()` and send to option contract.\r\n     *          3. Invoke `closeOptions()` to burn the options and release underlyings to this contract.\r\n     * @return  The amount of underlyingTokens released to this contract.\r\n     */\r\n    function _closeOptions(IOption optionToken) internal returns (uint256) {\r\n        address redeem = optionToken.redeemToken();\r\n        uint256 short = IERC20(redeem).balanceOf(address(this));\r\n        uint256 long = IERC20(address(optionToken)).balanceOf(getCaller());\r\n        uint256 proportional = CoreLib.getProportionalShortOptions(optionToken, long);\r\n        // IF user has more longs than proportional shorts, close the `short` amount.\r\n        if (proportional > short) {\r\n            proportional = short;\r\n        }\r\n\r\n        // If option is expired, transfer the amt of proportional thats larger.\r\n        if (optionToken.getExpiryTime() >= now) {\r\n            // Transfers the max proportional amount of short options to option contract.\r\n            IERC20(redeem).safeTransfer(address(optionToken), proportional);\r\n            // Pulls the max amount of long options and sends to option contract.\r\n            _transferFromCallerToReceiver(\r\n                address(optionToken),\r\n                CoreLib.getProportionalLongOptions(optionToken, proportional),\r\n                address(optionToken)\r\n            );\r\n        } else {\r\n            // If not expired, transfer all redeem in balance.\r\n            IERC20(redeem).safeTransfer(address(optionToken), short);\r\n        }\r\n        uint outputUnderlyings;\r\n        if(proportional > 0) {\r\n            (, ,  outputUnderlyings) = optionToken.closeOptions(address(this));\r\n        }\r\n        return outputUnderlyings;\r\n    }\r\n\r\n    /**\r\n     * @notice  Multi-step operation to exercise options.\r\n     *          1. Transfer balanceOf `strike` token to option contract.\r\n     *          2. Transfer `amount` of options to exercise to option contract.\r\n     *          3. Invoke `exerciseOptions()` and specify `getCaller()` as the receiver.\r\n     * @dev     If the balanceOf `strike` and `amount` of options are not in correct proportions, call will fail.\r\n     * @param   optionToken The option to exercise.\r\n     * @param   amount The quantity of options to exercise.\r\n     */\r\n    function _exerciseOptions(IOption optionToken, uint256 amount)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {\r\n        address strike = optionToken.getStrikeTokenAddress();\r\n        _transferBalanceToReceiver(strike, address(optionToken));\r\n        IERC20(address(optionToken)).safeTransfer(address(optionToken), amount);\r\n        return optionToken.exerciseOptions(getCaller(), amount, new bytes(0));\r\n    }\r\n\r\n    /**\r\n     * @notice  Transfers this contract's balance of Redeem tokens and invokes the redemption function.\r\n     * @param   optionToken The optionToken to redeem, not the redeem token itself.\r\n     */\r\n    function _redeemOptions(IOption optionToken) internal returns (uint256) {\r\n        address redeem = optionToken.redeemToken();\r\n        _transferBalanceToReceiver(redeem, address(optionToken));\r\n        return optionToken.redeemStrikeTokens(getCaller());\r\n    }\r\n\r\n    /**\r\n     * @notice  Utility function to transfer this contract's balance of `token` to `receiver`.\r\n     * @param   token The token to transfer.\r\n     * @param   receiver The address that receives the token.\r\n     * @return  Returns the quantity of `token` transferred.\r\n     */\r\n    function _transferBalanceToReceiver(address token, address receiver)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 quantity = IERC20(token).balanceOf(address(this));\r\n        IERC20(token).safeTransfer(receiver, quantity);\r\n        return quantity;\r\n    }\r\n\r\n    // ===== Fallback =====\r\n\r\n    receive() external payable {\r\n        assert(_msgSender() == address(_weth)); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // ===== View =====\r\n\r\n    /**\r\n     * @notice  Returns the Weth contract address.\r\n     */\r\n    function getWeth() public view override returns (IWETH) {\r\n        return _weth;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the state variable `_CALLER` in the Primitive Router.\r\n     */\r\n    function getCaller() public view override returns (address) {\r\n        return _primitiveRouter.getCaller();\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the Primitive Router contract address.\r\n     */\r\n    function getPrimitiveRouter() public view override returns (IPrimitiveRouter) {\r\n        return _primitiveRouter;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns whether or not `spender` is approved to spend `token`, from this contract.\r\n     */\r\n    function isApproved(address token, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _approved[token][spender];\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/CoreLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Swaps Lib\r\n * @author  Primitive\r\n * @notice  Library for calculating different proportions of long and short option tokens.\r\n * @dev     @primitivefi/v1-connectors@2.0.0\r\n */\r\n\r\nimport {IOption} from \"@primitivefi/contracts/contracts/option/interfaces/ITrader.sol\";\r\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\nlibrary CoreLib {\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    /**\r\n     * @dev     Calculates the proportional quantity of long option tokens per short option token.\r\n     * @notice  For each long option token, there is quoteValue / baseValue quantity of short option tokens.\r\n     * @param   optionToken The Option to use to calculate proportional amounts. Each option has different proportions.\r\n     * @param   short The amount of short options used to calculate the proportional amount of long option tokens.\r\n     * @return  The proportional amount of long option tokens based on `short`.\r\n     */\r\n    function getProportionalLongOptions(IOption optionToken, uint256 short)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return short.mul(optionToken.getBaseValue()).div(optionToken.getQuoteValue());\r\n    }\r\n\r\n    /**\r\n     * @dev     Calculates the proportional quantity of short option tokens per long option token.\r\n     * @notice  For each short option token, there is baseValue / quoteValue quantity of long option tokens.\r\n     * @param   optionToken The Option to use to calculate proportional amounts. Each option has different proportions.\r\n     * @param   long The amount of long options used to calculate the proportional amount of short option tokens.\r\n     * @return  The proportional amount of short option tokens based on `long`.\r\n     */\r\n    function getProportionalShortOptions(IOption optionToken, uint256 long)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return long.mul(optionToken.getQuoteValue()).div(optionToken.getBaseValue());\r\n    }\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB)\r\n        internal\r\n        pure\r\n        returns (address token0, address token1)\r\n    {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IPrimitiveConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {IPrimitiveRouter} from \"../interfaces/IPrimitiveRouter.sol\";\r\nimport {IWETH} from \"../interfaces/IWETH.sol\";\r\n\r\ninterface IPrimitiveConnector {\r\n    // ===== External =====\r\n\r\n    function checkApproval(address token, address spender) external returns (bool);\r\n\r\n    // ===== View =====\r\n\r\n    function getWeth() external view returns (IWETH);\r\n\r\n    function getCaller() external view returns (address);\r\n\r\n    function getPrimitiveRouter() external view returns (IPrimitiveRouter);\r\n\r\n    function isApproved(address token, address spender) external view returns (bool);\r\n}\r\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@primitivefi/contracts/contracts/option/interfaces/ITrader.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport { IOption } from \"./IOption.sol\";\r\n\r\ninterface ITrader {\r\n    function safeMint(\r\n        IOption optionToken,\r\n        uint256 mintQuantity,\r\n        address receiver\r\n    ) external returns (uint256, uint256);\r\n\r\n    function safeExercise(\r\n        IOption optionToken,\r\n        uint256 exerciseQuantity,\r\n        address receiver\r\n    ) external returns (uint256, uint256);\r\n\r\n    function safeRedeem(\r\n        IOption optionToken,\r\n        uint256 redeemQuantity,\r\n        address receiver\r\n    ) external returns (uint256);\r\n\r\n    function safeClose(\r\n        IOption optionToken,\r\n        uint256 closeQuantity,\r\n        address receiver\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function safeUnwind(\r\n        IOption optionToken,\r\n        uint256 unwindQuantity,\r\n        address receiver\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n"
    },
    "@primitivefi/contracts/contracts/option/interfaces/IOption.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ninterface IOption is IERC20 {\r\n    function mintOptions(address receiver) external returns (uint256, uint256);\r\n\r\n    function exerciseOptions(\r\n        address receiver,\r\n        uint256 outUnderlyings,\r\n        bytes calldata data\r\n    ) external returns (uint256, uint256);\r\n\r\n    function redeemStrikeTokens(address receiver) external returns (uint256);\r\n\r\n    function closeOptions(address receiver)\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function redeemToken() external view returns (address);\r\n\r\n    function getStrikeTokenAddress() external view returns (address);\r\n\r\n    function getUnderlyingTokenAddress() external view returns (address);\r\n\r\n    function getBaseValue() external view returns (uint256);\r\n\r\n    function getQuoteValue() external view returns (uint256);\r\n\r\n    function getExpiryTime() external view returns (uint256);\r\n\r\n    function underlyingCache() external view returns (uint256);\r\n\r\n    function strikeCache() external view returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function getCacheBalances() external view returns (uint256, uint256);\r\n\r\n    function getAssetAddresses()\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            address,\r\n            address\r\n        );\r\n\r\n    function getParameters()\r\n        external\r\n        view\r\n        returns (\r\n            address _underlyingToken,\r\n            address _strikeToken,\r\n            address _redeemToken,\r\n            uint256 _base,\r\n            uint256 _quote,\r\n            uint256 _expiry\r\n        );\r\n\r\n    function initRedeemToken(address _redeemToken) external;\r\n\r\n    function updateCacheBalances() external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/interfaces/IPrimitiveRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {\r\n    IOption,\r\n    IERC20\r\n} from \"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\";\r\nimport {\r\n    IRegistry\r\n} from \"@primitivefi/contracts/contracts/option/interfaces/IRegistry.sol\";\r\nimport {IWETH} from \"./IWETH.sol\";\r\n\r\ninterface IPrimitiveRouter {\r\n    // ===== Admin =====\r\n\r\n    function halt() external;\r\n\r\n    // ===== Registration =====\r\n    function setRegisteredOptions(address[] calldata optionAddresses)\r\n        external\r\n        returns (bool);\r\n\r\n    function setRegisteredConnectors(\r\n        address[] calldata connectors,\r\n        bool[] calldata isValid\r\n    ) external returns (bool);\r\n\r\n    // ===== Operations =====\r\n\r\n    function transferFromCaller(address token, uint256 amount) external returns (bool);\r\n\r\n    function transferFromCallerToReceiver(\r\n        address token,\r\n        uint256 amount,\r\n        address receiver\r\n    ) external returns (bool);\r\n\r\n    // ===== Execution =====\r\n\r\n    function executeCall(address connector, bytes calldata params) external payable;\r\n\r\n    // ==== View ====\r\n\r\n    function getWeth() external view returns (IWETH);\r\n\r\n    function getRoute() external view returns (address);\r\n\r\n    function getCaller() external view returns (address);\r\n\r\n    function getRegistry() external view returns (IRegistry);\r\n\r\n    function getRegisteredOption(address option) external view returns (bool);\r\n\r\n    function getRegisteredConnector(address connector) external view returns (bool);\r\n\r\n    function apiVersion() external pure returns (string memory);\r\n}\r\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "@primitivefi/contracts/contracts/option/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.2;\r\n\r\ninterface IRegistry {\r\n    function pauseDeployments() external;\r\n\r\n    function unpauseDeployments() external;\r\n\r\n    function deployOption(\r\n        address underlyingToken,\r\n        address strikeToken,\r\n        uint256 base,\r\n        uint256 quote,\r\n        uint256 expiry\r\n    ) external returns (address);\r\n\r\n    function setOptionFactory(address optionFactory_) external;\r\n\r\n    function setRedeemFactory(address redeemFactory_) external;\r\n\r\n    function optionFactory() external returns (address);\r\n\r\n    function redeemFactory() external returns (address);\r\n\r\n    function verifyToken(address tokenAddress) external;\r\n\r\n    function verifyExpiry(uint256 expiry) external;\r\n\r\n    function unverifyToken(address tokenAddress) external;\r\n\r\n    function unverifyExpiry(uint256 expiry) external;\r\n\r\n    function calculateOptionAddress(\r\n        address underlyingToken,\r\n        address strikeToken,\r\n        uint256 base,\r\n        uint256 quote,\r\n        uint256 expiry\r\n    ) external view returns (address);\r\n\r\n    function getOptionAddress(\r\n        address underlyingToken,\r\n        address strikeToken,\r\n        uint256 base,\r\n        uint256 quote,\r\n        uint256 expiry\r\n    ) external view returns (address);\r\n\r\n    function isVerifiedOption(address optionAddress)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n"
    },
    "contracts/test/ConnectorTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Connector TEST\r\n * @author  Primitive\r\n * @notice  Low-level abstract contract for Primitive Connectors to inherit from.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\nimport {PrimitiveConnector, IOption} from \"../connectors/PrimitiveConnector.sol\";\r\n\r\ncontract ConnectorTest is PrimitiveConnector {\r\n    event Log(address indexed caller);\r\n\r\n    constructor(address weth_, address primitiveRouter_)\r\n        public\r\n        PrimitiveConnector(weth_, primitiveRouter_)\r\n    {}\r\n\r\n    function depositETH() external payable returns (bool) {\r\n        emit Log(getCaller());\r\n        return _depositETH();\r\n    }\r\n\r\n    function withdrawETH() external returns (bool) {\r\n        emit Log(getCaller());\r\n        return _withdrawETH();\r\n    }\r\n\r\n    function transferFromCaller(address token, uint256 quantity) external returns (bool) {\r\n        emit Log(getCaller());\r\n        return _transferFromCaller(token, quantity);\r\n    }\r\n\r\n    function transferToCaller(address token) external returns (bool) {\r\n        emit Log(getCaller());\r\n        return _transferToCaller(token);\r\n    }\r\n\r\n    function transferFromCallerToReceiver(\r\n        address token,\r\n        uint256 quantity,\r\n        address receiver\r\n    ) external returns (bool) {\r\n        emit Log(getCaller());\r\n        return _transferFromCallerToReceiver(token, quantity, receiver);\r\n    }\r\n\r\n    function mintOptions(IOption optionToken, uint256 quantity)\r\n        external\r\n        returns (uint256, uint256)\r\n    {\r\n        emit Log(getCaller());\r\n        _transferFromCaller(optionToken.getUnderlyingTokenAddress(), quantity);\r\n        return _mintOptions(optionToken);\r\n    }\r\n\r\n    function mintOptionsToReceiver(\r\n        IOption optionToken,\r\n        uint256 quantity,\r\n        address receiver\r\n    ) external returns (uint256, uint256) {\r\n        emit Log(getCaller());\r\n        _transferFromCaller(optionToken.getUnderlyingTokenAddress(), quantity);\r\n        return _mintOptionsToReceiver(optionToken, receiver);\r\n    }\r\n\r\n    function mintOptionsFromCaller(IOption optionToken, uint256 quantity)\r\n        external\r\n        returns (uint256, uint256)\r\n    {\r\n        emit Log(getCaller());\r\n        return _mintOptionsFromCaller(optionToken, quantity);\r\n    }\r\n\r\n    function closeOptions(IOption optionToken, uint256 short) external returns (uint256) {\r\n        emit Log(getCaller());\r\n        _transferFromCaller(optionToken.redeemToken(), short);\r\n        return _closeOptions(optionToken);\r\n    }\r\n\r\n    function exerciseOptions(\r\n        IOption optionToken,\r\n        uint256 amount,\r\n        uint256 strikeAmount\r\n    ) external returns (uint256, uint256) {\r\n        _transferFromCaller(optionToken.getStrikeTokenAddress(), strikeAmount);\r\n        _transferFromCaller(address(optionToken), amount);\r\n        emit Log(getCaller());\r\n        return _exerciseOptions(optionToken, amount);\r\n    }\r\n\r\n    function redeemOptions(IOption optionToken, uint256 short)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        _transferFromCaller(optionToken.redeemToken(), short);\r\n        emit Log(getCaller());\r\n        return _redeemOptions(optionToken);\r\n    }\r\n\r\n    function transferBalanceToReceiver(address token, address receiver)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        emit Log(getCaller());\r\n        return _transferBalanceToReceiver(token, receiver);\r\n    }\r\n}\r\n"
    },
    "contracts/connectors/PrimitiveSwaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Router\r\n * @author  Primitive\r\n * @notice  Swap option tokens on Uniswap & Sushiswap venues.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n// Uniswap\r\nimport {\r\n    IUniswapV2Callee\r\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol\";\r\n// Primitive\r\nimport {\r\n    IPrimitiveSwaps,\r\n    IUniswapV2Router02,\r\n    IUniswapV2Factory,\r\n    IUniswapV2Pair,\r\n    IOption,\r\n    IERC20Permit\r\n} from \"../interfaces/IPrimitiveSwaps.sol\";\r\nimport {PrimitiveConnector} from \"./PrimitiveConnector.sol\";\r\nimport {SwapsLib, SafeMath} from \"../libraries/SwapsLib.sol\";\r\n\r\ninterface DaiPermit {\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\ncontract PrimitiveSwaps is\r\n    PrimitiveConnector,\r\n    IPrimitiveSwaps,\r\n    IUniswapV2Callee,\r\n    ReentrancyGuard\r\n{\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    event Initialized(address indexed from); // Emitted on deployment.\r\n    event Buy(\r\n        address indexed from,\r\n        address indexed option,\r\n        uint256 quantity,\r\n        uint256 premium\r\n    );\r\n    event Sell(\r\n        address indexed from,\r\n        address indexed option,\r\n        uint256 quantity,\r\n        uint256 payout\r\n    );\r\n\r\n    IUniswapV2Factory private _factory; // The Uniswap V2 _factory contract to get pair addresses from\r\n    IUniswapV2Router02 private _router; // The Uniswap contract used to interact with the protocol\r\n\r\n    modifier onlySelf() {\r\n        require(_msgSender() == address(this), \"PrimitiveSwaps: NOT_SELF\");\r\n        _;\r\n    }\r\n\r\n    // ===== Constructor =====\r\n    constructor(\r\n        address weth_,\r\n        address primitiveRouter_,\r\n        address factory_,\r\n        address router_\r\n    ) public PrimitiveConnector(weth_, primitiveRouter_) {\r\n        _factory = IUniswapV2Factory(factory_);\r\n        _router = IUniswapV2Router02(router_);\r\n        emit Initialized(_msgSender());\r\n    }\r\n\r\n    // ===== Swap Operations =====\r\n\r\n    /**\r\n     * @notice  IMPORTANT: amountOutMin parameter is the price to swap shortOptionTokens to underlyingTokens.\r\n     *          IMPORTANT: If the ratio between shortOptionTokens and underlyingTokens is 1:1, then only the swap fee (0.30%) has to be paid.\r\n     * @dev     Opens a longOptionToken position by minting long + short tokens, then selling the short tokens.\r\n     * @param   optionToken The option address.\r\n     * @param   amountOptions The quantity of longOptionTokens to purchase.\r\n     * @param   maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\r\n     * @return  Whether or not the call succeeded.\r\n     */\r\n    function openFlashLong(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium\r\n    ) public override nonReentrant onlyRegistered(optionToken) returns (bool) {\r\n        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\r\n        (IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\r\n        SwapsLib._flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            underlying, // Token to swap to, i.e. receive optimistically.\r\n            amountOptions, // Amount of underlying to optimistically receive to mint options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\"flashMintShortOptionsThenSwap(address,uint256,uint256)\")\r\n                    )\r\n                ),\r\n                optionToken, // Option token to mint with flash loaned tokens.\r\n                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\r\n                maxPremium // Total price paid (in underlyingTokens) for selling shortOptionTokens.\r\n            ) // End: Function to call in the callback.\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Executes the same as `openFlashLong`, but calls `permit` to pull underlying tokens.\r\n     */\r\n    function openFlashLongWithPermit(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public override nonReentrant onlyRegistered(optionToken) returns (bool) {\r\n        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\r\n        (IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\r\n        IERC20Permit(underlying).permit(\r\n            getCaller(),\r\n            address(_primitiveRouter),\r\n            maxPremium,\r\n            deadline,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n        SwapsLib._flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            underlying, // Token to swap to, i.e. receive optimistically.\r\n            amountOptions, // Amount of underlying to optimistically receive to mint options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\"flashMintShortOptionsThenSwap(address,uint256,uint256)\")\r\n                    )\r\n                ),\r\n                optionToken, // Option token to mint with flash loaned tokens.\r\n                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\r\n                maxPremium // Total price paid (in underlyingTokens) for selling shortOptionTokens.\r\n            ) // End: Function to call in the callback.\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Executes the same as `openFlashLongWithPermit`, but for DAI.\r\n     */\r\n    function openFlashLongWithDAIPermit(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public override nonReentrant onlyRegistered(optionToken) returns (bool) {\r\n        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\r\n        (IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\r\n        DaiPermit(underlying).permit(\r\n            getCaller(),\r\n            address(_primitiveRouter),\r\n            IERC20Permit(underlying).nonces(getCaller()),\r\n            deadline,\r\n            true,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n        SwapsLib._flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            underlying, // Token to swap to, i.e. receive optimistically.\r\n            amountOptions, // Amount of underlying to optimistically receive to mint options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\"flashMintShortOptionsThenSwap(address,uint256,uint256)\")\r\n                    )\r\n                ),\r\n                optionToken, // Option token to mint with flash loaned tokens.\r\n                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\r\n                maxPremium // Total price paid (in underlyingTokens) for selling shortOptionTokens.\r\n            ) // End: Function to call in the callback.\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Uses Ether to pay to purchase the option tokens.\r\n     *          IMPORTANT: amountOutMin parameter is the price to swap shortOptionTokens to underlyingTokens.\r\n     *          IMPORTANT: If the ratio between shortOptionTokens and underlyingTokens is 1:1, then only the swap fee (0.30%) has to be paid.\r\n     * @dev     Opens a longOptionToken position by minting long + short tokens, then selling the short tokens.\r\n     * @param   optionToken The option address.\r\n     * @param   amountOptions The quantity of longOptionTokens to purchase.\r\n     */\r\n    function openFlashLongWithETH(IOption optionToken, uint256 amountOptions)\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (bool)\r\n    {\r\n        require(msg.value > 0, \"PrimitiveSwaps: ZERO\"); // Fail early if no Ether was sent.\r\n        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\r\n        (IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\r\n        SwapsLib._flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            underlying, // Token to swap to, i.e. receive optimistically.\r\n            amountOptions, // Amount of underlying to optimistically receive to mint options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\r\n                            \"flashMintShortOptionsThenSwapWithETH(address,uint256,uint256)\"\r\n                        )\r\n                    )\r\n                ),\r\n                optionToken, // Option token to mint with flash loaned tokens\r\n                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\r\n                msg.value // total price paid (in underlyingTokens) for selling shortOptionTokens.\r\n            ) // End: Function to call in the callback.\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev     Closes a longOptionToken position by flash swapping in redeemTokens,\r\n     *          closing the option, and paying back in underlyingTokens.\r\n     * @notice  IMPORTANT: If minPayout is 0, this function will cost the caller to close the option, for no gain.\r\n     * @param   optionToken The address of the longOptionTokens to close.\r\n     * @param   amountRedeems The quantity of redeemTokens to borrow to close the options.\r\n     * @param   minPayout The minimum payout of underlyingTokens sent out to the user.\r\n     */\r\n    function closeFlashLong(\r\n        IOption optionToken,\r\n        uint256 amountRedeems,\r\n        uint256 minPayout\r\n    ) external override nonReentrant onlyRegistered(optionToken) returns (bool) {\r\n        // Calls pair.swap(), and executes `flashCloseLongOptionsThenSwap` in the `uniswapV2Callee` callback.\r\n        (IUniswapV2Pair pair, , address redeem) = getOptionPair(optionToken);\r\n        SwapsLib._flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            redeem, // Token to swap to, i.e. receive optimistically.\r\n            amountRedeems, // Amount of underlying to optimistically receive to close options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\"flashCloseLongOptionsThenSwap(address,uint256,uint256)\")\r\n                    )\r\n                ),\r\n                optionToken, // Option token to close with flash loaned redeemTokens.\r\n                amountRedeems, // Quantity of redeemTokens from flash loan to use to close options.\r\n                minPayout // Total remaining underlyingTokens after flash loan is paid.\r\n            ) // End: Function to call in the callback.\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev     Closes a longOptionToken position by flash swapping in redeemTokens,\r\n     *          closing the option, and paying back in underlyingTokens.\r\n     * @notice  IMPORTANT: If minPayout is 0, this function will cost the caller to close the option, for no gain.\r\n     * @param   optionToken The address of the longOptionTokens to close.\r\n     * @param   amountRedeems The quantity of redeemTokens to borrow to close the options.\r\n     * @param   minPayout The minimum payout of underlyingTokens sent out to the user.\r\n     */\r\n    function closeFlashLongForETH(\r\n        IOption optionToken,\r\n        uint256 amountRedeems,\r\n        uint256 minPayout\r\n    ) external override nonReentrant onlyRegistered(optionToken) returns (bool) {\r\n        // Calls pair.swap(), and executes `flashCloseLongOptionsThenSwapForETH` in the `uniswapV2Callee` callback.\r\n        (IUniswapV2Pair pair, , address redeem) = getOptionPair(optionToken);\r\n        SwapsLib._flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            redeem, // Token to swap to, i.e. receive optimistically.\r\n            amountRedeems, // Amount of underlying to optimistically receive to close options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\r\n                            \"flashCloseLongOptionsThenSwapForETH(address,uint256,uint256)\"\r\n                        )\r\n                    )\r\n                ),\r\n                optionToken, // Option token to close with flash loaned redeemTokens.\r\n                amountRedeems, // Quantity of redeemTokens from flash loan to use to close options.\r\n                minPayout // Total remaining underlyingTokens after flash loan is paid.\r\n            ) // End: Function to call in the callback.\r\n        );\r\n        return true;\r\n    }\r\n\r\n    // ===== Flash Callback Functions =====\r\n\r\n    /**\r\n     * @notice  Callback function executed in a UniswapV2Pair.swap() call for `openFlashLong`.\r\n     * @dev     Pays underlying token `premium` for `quantity` of `optionAddress` tokens.\r\n     * @param   optionAddress The address of the Option contract.\r\n     * @param   quantity The quantity of options to mint using borrowed underlyingTokens.\r\n     * @param   maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\r\n     * @return  Returns (amount, premium) of options purchased for total premium price.\r\n     */\r\n    function flashMintShortOptionsThenSwap(\r\n        address optionAddress,\r\n        uint256 quantity,\r\n        uint256 maxPremium\r\n    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {\r\n        IOption optionToken = IOption(optionAddress);\r\n        (IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\n        // Mint option and redeem tokens to this contract.\r\n        _mintOptions(optionToken);\r\n        // Get the repayment amounts.\r\n        (uint256 premium, uint256 redeemPremium) =\r\n            SwapsLib.repayOpen(_router, optionToken, quantity);\r\n        // If premium is non-zero and non-negative (most cases), send underlyingTokens to the pair as payment (premium).\r\n        if (premium > 0) {\r\n            // Check for users to not pay over their max desired value.\r\n            require(maxPremium >= premium, \"PrimitiveSwaps: MAX_PREMIUM\");\r\n            // Pull underlyingTokens from the `getCaller()` to pay the remainder of the flash swap.\r\n            _transferFromCaller(underlying, premium);\r\n            // Push underlying tokens back to the pair as repayment.\r\n            IERC20(underlying).safeTransfer(address(pair), premium);\r\n        }\r\n        // Pay pair in redeem tokens.\r\n        if (redeemPremium > 0) {\r\n            IERC20(redeem).safeTransfer(address(pair), redeemPremium);\r\n        }\r\n        // Return tokens to `getCaller()`.\r\n        _transferToCaller(redeem);\r\n        _transferToCaller(optionAddress);\r\n        emit Buy(getCaller(), optionAddress, quantity, premium);\r\n        return (quantity, premium);\r\n    }\r\n\r\n    /**\r\n     * @notice  Callback function executed in a UniswapV2Pair.swap() call for `openFlashLongWithETH`.\r\n     * @dev     Pays `premium` in ether for `quantity` of `optionAddress` tokens.\r\n     * @param   optionAddress The address of the Option contract.\r\n     * @param   quantity The quantity of options to mint using borrowed underlyingTokens.\r\n     * @param   maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\r\n     * @return  Returns (amount, premium) of options purchased for total premium price.\r\n     */\r\n    function flashMintShortOptionsThenSwapWithETH(\r\n        address optionAddress,\r\n        uint256 quantity,\r\n        uint256 maxPremium\r\n    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {\r\n        IOption optionToken = IOption(optionAddress);\r\n        (IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\n        require(underlying == address(_weth), \"PrimitiveSwaps: NOT_WETH\"); // Ensure Weth Call.\r\n        // Mint option and redeem tokens to this contract.\r\n        _mintOptions(optionToken);\r\n        // Get the repayment amounts.\r\n        (uint256 premium, uint256 redeemPremium) =\r\n            SwapsLib.repayOpen(_router, optionToken, quantity);\r\n        // If premium is non-zero and non-negative (most cases), send underlyingTokens to the pair as payment (premium).\r\n        if (premium > 0) {\r\n            // Check for users to not pay over their max desired value.\r\n            require(maxPremium >= premium, \"PrimitiveSwaps: MAX_PREMIUM\");\r\n            // Wrap exact Ether amount of `premium`.\r\n            _weth.deposit.value(premium)();\r\n            // Transfer Weth to pair to pay for premium.\r\n            IERC20(address(_weth)).safeTransfer(address(pair), premium);\r\n            // Return remaining Ether to caller.\r\n            _withdrawETH();\r\n        }\r\n        // Pay pair in redeem.\r\n        if (redeemPremium > 0) {\r\n            IERC20(redeem).safeTransfer(address(pair), redeemPremium);\r\n        }\r\n        // Return tokens to `getCaller()`.\r\n        _transferToCaller(redeem);\r\n        _transferToCaller(optionAddress);\r\n        emit Buy(getCaller(), optionAddress, quantity, premium);\r\n        return (quantity, premium);\r\n    }\r\n\r\n    /**\r\n     * @dev     Sends shortOptionTokens to _msgSender(), and pays back the UniswapV2Pair in underlyingTokens.\r\n     * @notice  IMPORTANT: If minPayout is 0, the `to` address is liable for negative payouts *if* that occurs.\r\n     * @param   optionAddress The address of the longOptionTokes to close.\r\n     * @param   flashLoanQuantity The quantity of shortOptionTokens borrowed to use to close longOptionTokens.\r\n     * @param   minPayout The minimum payout of underlyingTokens sent to the `to` address.\r\n     */\r\n    function flashCloseLongOptionsThenSwap(\r\n        address optionAddress,\r\n        uint256 flashLoanQuantity,\r\n        uint256 minPayout\r\n    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {\r\n        IOption optionToken = IOption(optionAddress);\r\n        (IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\n        // Close the options, releasing underlying tokens to this contract.\r\n        uint256 outputUnderlyings = _closeOptions(optionToken);\r\n        // Get repay amounts.\r\n        (uint256 payout, uint256 cost, uint256 outstanding) =\r\n            SwapsLib.repayClose(_router, optionToken, flashLoanQuantity);\r\n        if (payout > 0) {\r\n            cost = outputUnderlyings.sub(payout);\r\n        }\r\n        // Pay back the pair in underlyingTokens.\r\n        if (cost > 0) {\r\n            IERC20(underlying).safeTransfer(address(pair), cost);\r\n        }\r\n        if (outstanding > 0) {\r\n            // Pull underlyingTokens from the `getCaller()` to pay the remainder of the flash swap.\r\n            // Revert if the minPayout is less than or equal to the underlyingPayment of 0.\r\n            // There is 0 underlyingPayment in the case that outstanding > 0.\r\n            // This code branch can be successful by setting `minPayout` to 0.\r\n            // This means the user is willing to pay to close the position.\r\n            require(minPayout <= payout, \"PrimitiveSwaps: NEGATIVE_PAYOUT\");\r\n            _transferFromCallerToReceiver(underlying, outstanding, address(pair));\r\n        }\r\n        // If payout is non-zero and non-negative, send it to the `getCaller()` address.\r\n        if (payout > 0) {\r\n            // Revert if minPayout is greater than the actual payout.\r\n            require(payout >= minPayout, \"PrimitiveSwaps: MIN_PREMIUM\");\r\n            _transferToCaller(underlying);\r\n        }\r\n        emit Sell(getCaller(), optionAddress, flashLoanQuantity, payout);\r\n        return (payout, cost);\r\n    }\r\n\r\n    /**\r\n     * @dev     Sends shortOptionTokens to _msgSender(), and pays back the UniswapV2Pair in underlyingTokens.\r\n     * @notice  IMPORTANT: If minPayout is 0, the `getCaller()` address is liable for negative payouts *if* that occurs.\r\n     * @param   optionAddress The address of the longOptionTokes to close.\r\n     * @param   flashLoanQuantity The quantity of shortOptionTokens borrowed to use to close longOptionTokens.\r\n     * @param   minPayout The minimum payout of underlyingTokens sent to the `to` address.\r\n     */\r\n    function flashCloseLongOptionsThenSwapForETH(\r\n        address optionAddress,\r\n        uint256 flashLoanQuantity,\r\n        uint256 minPayout\r\n    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {\r\n        IOption optionToken = IOption(optionAddress);\r\n        (IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\n        require(underlying == address(_weth), \"PrimitiveSwaps: NOT_WETH\");\r\n        // Close the options, releasing underlying tokens to this contract.\r\n        _closeOptions(optionToken);\r\n        // Get repay amounts.\r\n        (uint256 payout, uint256 cost, uint256 outstanding) =\r\n            SwapsLib.repayClose(_router, optionToken, flashLoanQuantity);\r\n        // Pay back the pair in underlyingTokens.\r\n        if (cost > 0) {\r\n            IERC20(underlying).safeTransfer(address(pair), cost);\r\n        }\r\n        if (outstanding > 0) {\r\n            // Pull underlyingTokens from the `getCaller()` to pay the remainder of the flash swap.\r\n            // Revert if the minPayout is less than or equal to the underlyingPayment of 0.\r\n            // There is 0 underlyingPayment in the case that outstanding > 0.\r\n            // This code branch can be successful by setting `minPayout` to 0.\r\n            // This means the user is willing to pay to close the position.\r\n            require(minPayout <= payout, \"PrimitiveSwaps: NEGATIVE_PAYOUT\");\r\n            _transferFromCallerToReceiver(underlying, outstanding, address(pair));\r\n        }\r\n        // If payout is non-zero and non-negative, send it to the `getCaller()` address.\r\n        if (payout > 0) {\r\n            // Revert if minPayout is greater than the actual payout.\r\n            require(payout >= minPayout, \"PrimitiveSwaps: MIN_PREMIUM\");\r\n            _withdrawETH(); // Unwrap's this contract's balance of Weth and sends Ether to `getCaller()`.\r\n        }\r\n        emit Sell(getCaller(), optionAddress, flashLoanQuantity, payout);\r\n        return (payout, cost);\r\n    }\r\n\r\n    // ===== Flash Loans =====\r\n\r\n    /**\r\n     * @dev     The callback function triggered in a UniswapV2Pair.swap() call when the `data` parameter has data.\r\n     * @param   sender The original _msgSender() of the UniswapV2Pair.swap() call.\r\n     * @param   amount0 The quantity of token0 received to the `to` address in the swap() call.\r\n     * @param   amount1 The quantity of token1 received to the `to` address in the swap() call.\r\n     * @param   data The payload passed in the `data` parameter of the swap() call.\r\n     */\r\n    function uniswapV2Call(\r\n        address sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external override(IPrimitiveSwaps, IUniswapV2Callee) {\r\n        assert(\r\n            _msgSender() ==\r\n                _factory.getPair(\r\n                    IUniswapV2Pair(_msgSender()).token0(),\r\n                    IUniswapV2Pair(_msgSender()).token1()\r\n                )\r\n        ); // Ensure that _msgSender() is actually a V2 pair.\r\n        require(sender == address(this), \"PrimitiveSwaps: NOT_SENDER\"); // Ensure called by this contract.\r\n        (bool success, bytes memory returnData) = address(this).call(data); // Execute the callback.\r\n        (uint256 amountA, uint256 amountB) = abi.decode(returnData, (uint256, uint256));\r\n        require(\r\n            success && (returnData.length == 0 || amountA > 0 || amountB > 0),\r\n            \"PrimitiveSwaps: CALLBACK\"\r\n        );\r\n    }\r\n\r\n    // ===== View =====\r\n\r\n    /**\r\n     * @notice  Gets the UniswapV2Router02 contract address.\r\n     */\r\n    function getRouter() public view override returns (IUniswapV2Router02) {\r\n        return _router;\r\n    }\r\n\r\n    /**\r\n     * @notice  Gets the UniswapV2Factory contract address.\r\n     */\r\n    function getFactory() public view override returns (IUniswapV2Factory) {\r\n        return _factory;\r\n    }\r\n\r\n    /**\r\n     * @notice  Fetchs the Uniswap Pair for an option's redeemToken and underlyingToken params.\r\n     * @param   option The option token to get the corresponding UniswapV2Pair market.\r\n     * @return  The pair address, as well as the tokens of the pair.\r\n     */\r\n    function getOptionPair(IOption option)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            IUniswapV2Pair,\r\n            address,\r\n            address\r\n        )\r\n    {\r\n        address redeem = option.redeemToken();\r\n        address underlying = option.getUnderlyingTokenAddress();\r\n        IUniswapV2Pair pair = IUniswapV2Pair(_factory.getPair(redeem, underlying));\r\n        return (pair, underlying, redeem);\r\n    }\r\n\r\n    /**\r\n     * @dev     Calculates the effective premium, denominated in underlyingTokens, to buy `quantity` of `optionToken`s.\r\n     * @notice  UniswapV2 adds a 0.3009027% fee which is applied to the premium as 0.301%.\r\n     *          IMPORTANT: If the pair's reserve ratio is incorrect, there could be a 'negative' premium.\r\n     *          Buying negative premium options will pay out redeemTokens.\r\n     *          An 'incorrect' ratio occurs when the (reserves of redeemTokens / strike ratio) >= reserves of underlyingTokens.\r\n     *          Implicitly uses the `optionToken`'s underlying and redeem tokens for the pair.\r\n     * @param   optionToken The optionToken to get the premium cost of purchasing.\r\n     * @param   quantity The quantity of long option tokens that will be purchased.\r\n     * @return  (uint, uint) Returns the `premium` to buy `quantity` of `optionToken` and the `negativePremium`.\r\n     */\r\n    function getOpenPremium(IOption optionToken, uint256 quantity)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256, uint256)\r\n    {\r\n        return SwapsLib.getOpenPremium(_router, optionToken, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev     Calculates the effective premium, denominated in underlyingTokens, to sell `optionToken`s.\r\n     * @param   optionToken The optionToken to get the premium cost of purchasing.\r\n     * @param   quantity The quantity of short option tokens that will be closed.\r\n     * @return  (uint, uint) Returns the `premium` to sell `quantity` of `optionToken` and the `negativePremium`.\r\n     */\r\n    function getClosePremium(IOption optionToken, uint256 quantity)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256, uint256)\r\n    {\r\n        return SwapsLib.getClosePremium(_router, optionToken, quantity);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/interfaces/IPrimitiveSwaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {\r\n    IUniswapV2Router02\r\n} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport {\r\n    IUniswapV2Factory\r\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\r\nimport {IUniswapV2Pair} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\nimport {IOption} from \"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\";\r\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\r\n\r\ninterface IPrimitiveSwaps {\r\n    // ==== External Functions ====\r\n\r\n    function openFlashLong(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium\r\n    ) external returns (bool);\r\n\r\n    function openFlashLongWithPermit(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (bool);\r\n\r\n    function openFlashLongWithDAIPermit(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (bool);\r\n\r\n    function openFlashLongWithETH(IOption optionToken, uint256 amountOptions)\r\n        external\r\n        payable\r\n        returns (bool);\r\n\r\n    function closeFlashLong(\r\n        IOption optionToken,\r\n        uint256 amountRedeems,\r\n        uint256 minPayout\r\n    ) external returns (bool);\r\n\r\n    function closeFlashLongForETH(\r\n        IOption optionToken,\r\n        uint256 amountRedeems,\r\n        uint256 minPayout\r\n    ) external returns (bool);\r\n\r\n    // ===== Callback =====\r\n\r\n    function uniswapV2Call(\r\n        address sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    // ==== View ====\r\n\r\n    function getRouter() external view returns (IUniswapV2Router02);\r\n\r\n    function getFactory() external view returns (IUniswapV2Factory);\r\n\r\n    function getOptionPair(IOption option)\r\n        external\r\n        view\r\n        returns (\r\n            IUniswapV2Pair,\r\n            address,\r\n            address\r\n        );\r\n\r\n    function getOpenPremium(IOption optionToken, uint256 quantity)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function getClosePremium(IOption optionToken, uint256 quantity)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n}\r\n"
    },
    "contracts/libraries/SwapsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Swaps Lib\r\n * @author  Primitive\r\n * @notice  Library for Swap Logic for Uniswap AMM.\r\n * @dev     @primitivefi/v1-connectors@2.0.0\r\n */\r\n\r\nimport {\r\n    IUniswapV2Router02\r\n} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport {IUniswapV2Pair} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\nimport {CoreLib, IOption, SafeMath} from \"./CoreLib.sol\";\r\n\r\nlibrary SwapsLib {\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    /**\r\n     * @notice  Passes in `params` to the UniswapV2Pair.swap() function to trigger the callback.\r\n     * @param   pair The Uniswap Pair to call.\r\n     * @param   token The token in the Pair to swap to, and thus optimistically receive.\r\n     * @param   amount The quantity of `token`s to optimistically receive first.\r\n     * @param   params  The data to call from this contract, using the `uniswapV2Callee` callback.\r\n     * @return  Whether or not the swap() call suceeded.\r\n     */\r\n    function _flashSwap(\r\n        IUniswapV2Pair pair,\r\n        address token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) internal returns (bool) {\r\n        // Receives `amount` of `token` to this contract address.\r\n        uint256 amount0Out = pair.token0() == token ? amount : 0;\r\n        uint256 amount1Out = pair.token0() == token ? 0 : amount;\r\n        // Execute the callback function in params.\r\n        pair.swap(amount0Out, amount1Out, address(this), params);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Gets the amounts to pay out, pay back, and outstanding cost.\r\n     * @param   router The UniswapV2Router02 to use for calculating `amountsOut`.\r\n     * @param   optionToken The option token to use for fetching its corresponding Uniswap Pair.\r\n     * @param   redeemAmount The quantity of REDEEM tokens, with `quoteValue` units, needed to close the options.\r\n     */\r\n    function repayClose(\r\n        IUniswapV2Router02 router,\r\n        IOption optionToken,\r\n        uint256 redeemAmount\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        // Outstanding is the cost remaining, should be 0 in most cases.\r\n        // Payout is the `premium` that the original caller receives in underlyingTokens.\r\n        (uint256 payout, uint256 outstanding) =\r\n            getClosePremium(router, optionToken, redeemAmount);\r\n\r\n        // In most cases there will be an underlying payout, which is subtracted from the redeemAmount.\r\n        uint256 cost = CoreLib.getProportionalLongOptions(optionToken, redeemAmount);\r\n        if (payout > 0) {\r\n            cost = cost.sub(payout);\r\n        }\r\n        return (payout, cost, outstanding);\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the swap amounts required to return to repay the flash loan used to open a long position.\r\n     * @param   router The UniswapV2Router02 to use for calculating `amountsOut`.\r\n     * @param   optionToken The option token to use for fetching its corresponding Uniswap Pair.\r\n     * @param   underlyingAmount The quantity of UNDERLYING tokens, with `baseValue` units, needed to open the options.\r\n     */\r\n    function repayOpen(\r\n        IUniswapV2Router02 router,\r\n        IOption optionToken,\r\n        uint256 underlyingAmount\r\n    ) internal view returns (uint256, uint256) {\r\n        // Premium is the `underlyingTokens` required to buy the `optionToken`.\r\n        // ExtraRedeems is the `redeemTokens` that are remaining.\r\n        // If `premium` is not 0, `extraRedeems` should be 0, else `extraRedeems` is the payout (a negative premium).\r\n        (uint256 premium, uint256 extraRedeems) =\r\n            getOpenPremium(router, optionToken, underlyingAmount);\r\n\r\n        uint256 redeemPremium =\r\n            CoreLib.getProportionalShortOptions(optionToken, underlyingAmount);\r\n\r\n        if (extraRedeems > 0) {\r\n            redeemPremium = redeemPremium.sub(extraRedeems);\r\n        }\r\n        return (premium, redeemPremium);\r\n    }\r\n\r\n    /**\r\n     * @dev    Calculates the effective premium, denominated in underlyingTokens, to buy `quantity` of `optionToken`s.\r\n     * @notice UniswapV2 adds a 0.3009027% fee which is applied to the premium as 0.301%.\r\n     *         IMPORTANT: If the pair's reserve ratio is incorrect, there could be a 'negative' premium.\r\n     *         Buying negative premium options will pay out redeemTokens.\r\n     *         An 'incorrect' ratio occurs when the (reserves of redeemTokens / strike ratio) >= reserves of underlyingTokens.\r\n     *         Implicitly uses the `optionToken`'s underlying and redeem tokens for the pair.\r\n     * @param  router The UniswapV2Router02 contract.\r\n     * @param  optionToken The optionToken to get the premium cost of purchasing.\r\n     * @param  quantity The quantity of long option tokens that will be purchased.\r\n     */\r\n    function getOpenPremium(\r\n        IUniswapV2Router02 router,\r\n        IOption optionToken,\r\n        uint256 quantity\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            /* override */\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        // longOptionTokens are opened by doing a swap from redeemTokens to underlyingTokens effectively.\r\n        address[] memory path = new address[](2);\r\n        path[0] = optionToken.redeemToken();\r\n        path[1] = optionToken.getUnderlyingTokenAddress();\r\n\r\n        // `quantity` of underlyingTokens are output from the swap.\r\n        // They are used to mint options, which will mint `quantity` * quoteValue / baseValue amount of redeemTokens.\r\n        uint256 redeemsMinted =\r\n            CoreLib.getProportionalShortOptions(optionToken, quantity);\r\n\r\n        // The loanRemainderInUnderlyings will be the amount of underlyingTokens that are needed from the original\r\n        // transaction caller in order to pay the flash swap.\r\n        // IMPORTANT: THIS IS EFFECTIVELY THE PREMIUM PAID IN UNDERLYINGTOKENS TO PURCHASE THE OPTIONTOKEN.\r\n        uint256 loanRemainderInUnderlyings;\r\n\r\n        // Economically, negativePremiumPaymentInRedeems value should always be 0.\r\n        // In the case that we minted more redeemTokens than are needed to pay back the flash swap,\r\n        // (short -> underlying is a positive trade), there is an effective negative premium.\r\n        // In that case, this function will send out `negativePremiumAmount` of redeemTokens to the original caller.\r\n        // This means the user gets to keep the extra redeemTokens for free.\r\n        // Negative premium amount is the opposite difference of the loan remainder: (paid - flash loan amount)\r\n        uint256 negativePremiumPaymentInRedeems;\r\n\r\n        // Since the borrowed amount is underlyingTokens, and we are paying back in redeemTokens,\r\n        // we need to see how much redeemTokens must be returned for the borrowed amount.\r\n        // We can find that value by doing the normal swap math, getAmountsIn will give us the amount\r\n        // of redeemTokens are needed for the output amount of the flash loan.\r\n        // IMPORTANT: amountsIn[0] is how many short tokens we need to pay back.\r\n        // This value is most likely greater than the amount of redeemTokens minted.\r\n        uint256[] memory amountsIn = router.getAmountsIn(quantity, path);\r\n        uint256 redeemsRequired = amountsIn[0]; // the amountIn of redeemTokens based on the amountOut of `quantity`.\r\n        // If redeemsMinted is greater than redeems required, there is a cost of 0, implying a negative premium.\r\n        uint256 redeemCostRemaining =\r\n            redeemsRequired > redeemsMinted ? redeemsRequired.sub(redeemsMinted) : 0;\r\n        // If there is a negative premium, calculate the quantity of remaining redeemTokens after the `redeemsMinted` is spent.\r\n        negativePremiumPaymentInRedeems = redeemsMinted > redeemsRequired\r\n            ? redeemsMinted.sub(redeemsRequired)\r\n            : 0;\r\n\r\n        // In most cases, there will be an outstanding cost (assuming we minted less redeemTokens than the\r\n        // required amountIn of redeemTokens for the swap).\r\n        if (redeemCostRemaining > 0) {\r\n            // The user won't want to pay back the remaining cost in redeemTokens,\r\n            // because they borrowed underlyingTokens to mint them in the first place.\r\n            // So instead, we get the quantity of underlyingTokens that could be paid instead.\r\n            // We can calculate this using normal swap math.\r\n            // getAmountsOut will return the quantity of underlyingTokens that are output,\r\n            // based on some input of redeemTokens.\r\n            // The input redeemTokens is the remaining redeemToken cost, and the output\r\n            // underlyingTokens is the proportional amount of underlyingTokens.\r\n            // amountsOut[1] is then the outstanding flash loan value denominated in underlyingTokens.\r\n            uint256[] memory amountsOut = router.getAmountsOut(redeemCostRemaining, path);\r\n\r\n            // Returning withdrawn tokens to the pair has a fee of .003 / .997 = 0.3009027% which must be applied.\r\n            loanRemainderInUnderlyings = (\r\n                amountsOut[1].mul(100000).add(amountsOut[1].mul(301))\r\n            )\r\n                .div(100000);\r\n        }\r\n        return (loanRemainderInUnderlyings, negativePremiumPaymentInRedeems);\r\n    }\r\n\r\n    /**\r\n     * @dev    Calculates the effective premium, denominated in underlyingTokens, to sell `optionToken`s.\r\n     * @param  router The UniswapV2Router02 contract.\r\n     * @param  optionToken The optionToken to get the premium cost of purchasing.\r\n     * @param  quantity The quantity of short option tokens that will be closed.\r\n     */\r\n    function getClosePremium(\r\n        IUniswapV2Router02 router,\r\n        IOption optionToken,\r\n        uint256 quantity\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            /* override */\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        // longOptionTokens are closed by doing a swap from underlyingTokens to redeemTokens.\r\n        address[] memory path = new address[](2);\r\n        path[0] = optionToken.getUnderlyingTokenAddress();\r\n        path[1] = optionToken.redeemToken();\r\n        uint256 outputUnderlyings =\r\n            CoreLib.getProportionalLongOptions(optionToken, quantity);\r\n        // The loanRemainder will be the amount of underlyingTokens that are needed from the original\r\n        // transaction caller in order to pay the flash swap.\r\n        uint256 loanRemainder;\r\n\r\n        // Economically, underlyingPayout value should always be greater than 0, or this trade shouldn't be made.\r\n        // If an underlyingPayout is greater than 0, it means that the redeemTokens borrowed are worth less than the\r\n        // underlyingTokens received from closing the redeemToken<>optionTokens.\r\n        // If the redeemTokens are worth more than the underlyingTokens they are entitled to,\r\n        // then closing the redeemTokens will cost additional underlyingTokens. In this case,\r\n        // the transaction should be reverted. Or else, the user is paying extra at the expense of\r\n        // rebalancing the pool.\r\n        uint256 underlyingPayout;\r\n\r\n        // Since the borrowed amount is redeemTokens, and we are paying back in underlyingTokens,\r\n        // we need to see how much underlyingTokens must be returned for the borrowed amount.\r\n        // We can find that value by doing the normal swap math, getAmountsIn will give us the amount\r\n        // of underlyingTokens are needed for the output amount of the flash loan.\r\n        // IMPORTANT: amountsIn 0 is how many underlyingTokens we need to pay back.\r\n        // This value is most likely greater than the amount of underlyingTokens received from closing.\r\n        uint256[] memory amountsIn = router.getAmountsIn(quantity, path);\r\n\r\n        uint256 underlyingsRequired = amountsIn[0]; // the amountIn required of underlyingTokens based on the amountOut of flashloanQuantity\r\n        // If outputUnderlyings (received from closing) is greater than underlyings required,\r\n        // there is a positive payout.\r\n        underlyingPayout = outputUnderlyings > underlyingsRequired\r\n            ? outputUnderlyings.sub(underlyingsRequired)\r\n            : 0;\r\n\r\n        // If there is a negative payout, calculate the remaining cost of underlyingTokens.\r\n        uint256 underlyingCostRemaining =\r\n            underlyingsRequired > outputUnderlyings\r\n                ? underlyingsRequired.sub(outputUnderlyings)\r\n                : 0;\r\n\r\n        // In the case that there is a negative payout (additional underlyingTokens are required),\r\n        // get the remaining cost into the `loanRemainder` variable and also check to see\r\n        // if a user is willing to pay the negative cost. There is no rational economic incentive for this.\r\n        if (underlyingCostRemaining > 0) {\r\n            loanRemainder = underlyingCostRemaining;\r\n        }\r\n        return (underlyingPayout, loanRemainder);\r\n    }\r\n}\r\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20Permit {\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/connectors/PrimitiveLiquidity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Liquidity\r\n * @author  Primitive\r\n * @notice  Manage liquidity on Uniswap & Sushiswap Venues.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n// Interfaces\r\nimport {\r\n    IPrimitiveLiquidity,\r\n    IUniswapV2Router02,\r\n    IUniswapV2Factory,\r\n    IUniswapV2Pair,\r\n    IERC20Permit,\r\n    IOption\r\n} from \"../interfaces/IPrimitiveLiquidity.sol\";\r\n// Primitive\r\nimport {PrimitiveConnector} from \"./PrimitiveConnector.sol\";\r\nimport {CoreLib, SafeMath} from \"../libraries/CoreLib.sol\";\r\n\r\ninterface DaiPermit {\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\ncontract PrimitiveLiquidity is PrimitiveConnector, IPrimitiveLiquidity, ReentrancyGuard {\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    event Initialized(address indexed from); // Emitted on deployment.\r\n    event AddLiquidity(address indexed from, address indexed option, uint256 liquidity);\r\n    event RemoveLiquidity(\r\n        address indexed from,\r\n        address indexed option,\r\n        uint256 totalUnderlying\r\n    );\r\n\r\n    IUniswapV2Factory private _factory; // The Uniswap V2 factory contract to get pair addresses from.\r\n    IUniswapV2Router02 private _router; // The Uniswap Router contract used to interact with the protocol.\r\n\r\n    // ===== Constructor =====\r\n    constructor(\r\n        address weth_,\r\n        address primitiveRouter_,\r\n        address factory_,\r\n        address router_\r\n    ) public PrimitiveConnector(weth_, primitiveRouter_) {\r\n        _factory = IUniswapV2Factory(factory_);\r\n        _router = IUniswapV2Router02(router_);\r\n        emit Initialized(_msgSender());\r\n    }\r\n\r\n    // ===== Liquidity Operations =====\r\n\r\n    /**\r\n     * @dev     Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting redeemTokens with underlyingTokens.\r\n     * @notice  Pulls underlying tokens from `getCaller()` and pushes UNI-V2 liquidity tokens to the \"getCaller()\" address.\r\n     *          underlyingToken -> redeemToken -> UNI-V2.\r\n     * @param   optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\r\n     * @param   quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\r\n     * @param   amountBMax The quantity of underlyingTokens to add with redeemTokens to the Uniswap V2 Pair.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\r\n     * @param   deadline The timestamp to expire a pending transaction.\r\n     */\r\n    function addShortLiquidityWithUnderlying(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 amountA;\r\n        uint256 amountB;\r\n        uint256 liquidity;\r\n        address underlying = IOption(optionAddress).getUnderlyingTokenAddress();\r\n        // Pulls total = (quantityOptions + amountBMax) of underlyingTokens from `getCaller()` to this contract.\r\n        {\r\n            uint256 sum = quantityOptions.add(amountBMax);\r\n            _transferFromCaller(underlying, sum);\r\n        }\r\n        // Pushes underlyingTokens to option contract and mints option + redeem tokens to this contract.\r\n        IERC20(underlying).safeTransfer(optionAddress, quantityOptions);\r\n        (, uint256 outputRedeems) = IOption(optionAddress).mintOptions(address(this));\r\n\r\n        {\r\n            // scope for adding exact liquidity, avoids stack too deep errors\r\n            IOption optionToken = IOption(optionAddress);\r\n            address redeem = optionToken.redeemToken();\r\n            AddAmounts memory params;\r\n            params.amountAMax = outputRedeems;\r\n            params.amountBMax = amountBMax;\r\n            params.amountAMin = outputRedeems;\r\n            params.amountBMin = amountBMin;\r\n            params.deadline = deadline;\r\n            // Approves Uniswap V2 Pair pull tokens from this contract.\r\n            checkApproval(redeem, address(_router));\r\n            checkApproval(underlying, address(_router));\r\n            // Adds liquidity to Uniswap V2 Pair and returns liquidity shares to the \"getCaller()\" address.\r\n            (amountA, amountB, liquidity) = _addLiquidity(redeem, underlying, params);\r\n            // Check for exact liquidity provided.\r\n            assert(amountA == outputRedeems);\r\n            // Return remaining tokens\r\n            _transferToCaller(underlying);\r\n            _transferToCaller(redeem);\r\n            _transferToCaller(address(optionToken));\r\n        }\r\n        emit AddLiquidity(getCaller(), optionAddress, liquidity);\r\n        return (amountA, amountB, liquidity);\r\n    }\r\n\r\n    /**\r\n     * @dev     Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting shortOptionTokens with underlyingTokens.\r\n     * @notice  Pulls underlying tokens from `getCaller()` and pushes UNI-V2 liquidity tokens to the \"getCaller()\" address.\r\n     *          underlyingToken -> redeemToken -> UNI-V2. Uses permit so user does not need to `approve()` our contracts.\r\n     * @param   optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\r\n     * @param   quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\r\n     * @param   amountBMax The quantity of underlyingTokens to add with shortOptionTokens to the Uniswap V2 Pair.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\r\n     * @param   deadline The timestamp to expire a pending transaction.\r\n     */\r\n    function addShortLiquidityWithUnderlyingWithPermit(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        override\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        {\r\n            // avoids stack too deep errors\r\n            address underlying = IOption(optionAddress).getUnderlyingTokenAddress();\r\n            uint256 sum = quantityOptions.add(amountBMax);\r\n            IERC20Permit(underlying).permit(\r\n                getCaller(),\r\n                address(_primitiveRouter),\r\n                sum,\r\n                deadline,\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n        }\r\n        return\r\n            addShortLiquidityWithUnderlying(\r\n                optionAddress,\r\n                quantityOptions,\r\n                amountBMax,\r\n                amountBMin,\r\n                deadline\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice  Specialized function for `permit` calling on Put options (DAI).\r\n     */\r\n    function addShortLiquidityDAIWithPermit(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        override\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        address underlying = IOption(optionAddress).getUnderlyingTokenAddress();\r\n        DaiPermit(underlying).permit(\r\n            getCaller(),\r\n            address(_primitiveRouter),\r\n            IERC20Permit(underlying).nonces(getCaller()),\r\n            deadline,\r\n            true,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n        return\r\n            addShortLiquidityWithUnderlying(\r\n                optionAddress,\r\n                quantityOptions,\r\n                amountBMax,\r\n                amountBMin,\r\n                deadline\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev     Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting shortOptionTokens with underlyingTokens.\r\n     * @notice  Pulls underlying tokens from `getCaller()` and pushes UNI-V2 liquidity tokens to the `getCaller()` address.\r\n     *          underlyingToken -> redeemToken -> UNI-V2.\r\n     * @param   optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\r\n     * @param   quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\r\n     * @param   amountBMax The quantity of underlyingTokens to add with shortOptionTokens to the Uniswap V2 Pair.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\r\n     * @param   deadline The timestamp to expire a pending transaction.\r\n     */\r\n    function addShortLiquidityWithETH(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        require(\r\n            quantityOptions.add(amountBMax) >= msg.value,\r\n            \"PrimitiveLiquidity: INSUFFICIENT\"\r\n        );\r\n\r\n        uint256 amountA;\r\n        uint256 amountB;\r\n        uint256 liquidity;\r\n        address underlying = IOption(optionAddress).getUnderlyingTokenAddress();\r\n        require(underlying == address(_weth), \"PrimitiveLiquidity: NOT_WETH\");\r\n\r\n        _depositETH(); // Wraps `msg.value` to Weth.\r\n        // Pushes Weth to option contract and mints option + redeem tokens to this contract.\r\n        IERC20(underlying).safeTransfer(optionAddress, quantityOptions);\r\n        (, uint256 outputRedeems) = IOption(optionAddress).mintOptions(address(this));\r\n\r\n        {\r\n            // scope for adding exact liquidity, avoids stack too deep errors\r\n            IOption optionToken = IOption(optionAddress);\r\n            address redeem = optionToken.redeemToken();\r\n            AddAmounts memory params;\r\n            params.amountAMax = outputRedeems;\r\n            params.amountBMax = amountBMax;\r\n            params.amountAMin = outputRedeems;\r\n            params.amountBMin = amountBMin;\r\n            params.deadline = deadline;\r\n\r\n            // Approves Uniswap V2 Pair pull tokens from this contract.\r\n            checkApproval(redeem, address(_router));\r\n            checkApproval(underlying, address(_router));\r\n            // Adds liquidity to Uniswap V2 Pair.\r\n            (amountA, amountB, liquidity) = _addLiquidity(redeem, underlying, params);\r\n            assert(amountA == outputRedeems); // Check for exact liquidity provided.\r\n            // Return remaining tokens and ether.\r\n            _withdrawETH();\r\n            _transferToCaller(redeem);\r\n            _transferToCaller(address(optionToken));\r\n        }\r\n        emit AddLiquidity(getCaller(), optionAddress, liquidity);\r\n        return (amountA, amountB, liquidity);\r\n    }\r\n\r\n    struct AddAmounts {\r\n        uint256 amountAMax;\r\n        uint256 amountBMax;\r\n        uint256 amountAMin;\r\n        uint256 amountBMin;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /**\r\n     * @notice  Calls UniswapV2Router02.addLiquidity() function using this contract's tokens.\r\n     * @param   tokenA The first token of the Uniswap Pair to add as liquidity.\r\n     * @param   tokenB The second token of the Uniswap Pair to add as liquidity.\r\n     * @param   params The amounts specified to be added as liquidity. Adds exact short options.\r\n     * @return  Returns the (amountTokenA, amountTokenB, liquidity).\r\n     */\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        AddAmounts memory params\r\n    )\r\n        internal\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return\r\n            _router.addLiquidity(\r\n                tokenA,\r\n                tokenB,\r\n                params.amountAMax,\r\n                params.amountBMax,\r\n                params.amountAMin,\r\n                params.amountBMin,\r\n                getCaller(),\r\n                params.deadline\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev     Combines Uniswap V2 Router \"removeLiquidity\" function with Primitive \"closeOptions\" function.\r\n     * @notice  Pulls UNI-V2 liquidity shares with shortOption<>underlying token, and optionTokens from `getCaller()`.\r\n     *          Then closes the longOptionTokens and withdraws underlyingTokens to the `getCaller()` address.\r\n     *          Sends underlyingTokens from the burned UNI-V2 liquidity shares to the `getCaller()` address.\r\n     *          UNI-V2 -> optionToken -> underlyingToken.\r\n     * @param   optionAddress The address of the option that will be closed from burned UNI-V2 liquidity shares.\r\n     * @param   liquidity The quantity of liquidity tokens to pull from `getCaller()` and burn.\r\n     * @param   amountAMin The minimum quantity of shortOptionTokens to receive from removing liquidity.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens to receive from removing liquidity.\r\n     */\r\n    function removeShortLiquidityThenCloseOptions(\r\n        address optionAddress,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin\r\n    )\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (uint256)\r\n    {\r\n        IOption optionToken = IOption(optionAddress);\r\n        (IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\n        // Gets amounts struct.\r\n        RemoveAmounts memory params;\r\n        params.liquidity = liquidity;\r\n        params.amountAMin = amountAMin;\r\n        params.amountBMin = amountBMin;\r\n        // Pulls lp tokens from `getCaller()` and pushes them to the pair in preparation to invoke `burn()`.\r\n        _transferFromCallerToReceiver(address(pair), liquidity, address(pair));\r\n        // Calls `burn` on the `pair`, returning amounts to this contract.\r\n        (, uint256 underlyingAmount) = _removeLiquidity(pair, redeem, underlying, params);\r\n        uint256 underlyingProceeds = _closeOptions(optionToken); // Returns amount of underlying tokens released.\r\n        // Return remaining tokens/ether.\r\n        _withdrawETH(); // Unwraps Weth and sends ether to `getCaller()`.\r\n        _transferToCaller(redeem); // Push any remaining redeemTokens from removing liquidity (dust).\r\n        _transferToCaller(underlying); // Pushes underlying token to `getCaller()`.\r\n        uint256 sum = underlyingProceeds.add(underlyingAmount); // Total underlyings sent to `getCaller()`.\r\n        emit RemoveLiquidity(getCaller(), address(optionToken), sum);\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     * @notice  Pulls LP tokens, burns them, removes liquidity, pull option token, burns then, pushes all underlying tokens.\r\n     * @dev     Uses permit to pull LP tokens.\r\n     * @param   optionAddress The address of the option that will be closed from burned UNI-V2 liquidity shares.\r\n     * @param   liquidity The quantity of liquidity tokens to pull from _msgSender() and burn.\r\n     * @param   amountAMin The minimum quantity of shortOptionTokens to receive from removing liquidity.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens to receive from removing liquidity.\r\n     * @param   deadline The timestamp to expire a pending transaction and `permit` call.\r\n     */\r\n    function removeShortLiquidityThenCloseOptionsWithPermit(\r\n        address optionAddress,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external override onlyRegistered(IOption(optionAddress)) returns (uint256) {\r\n        IOption optionToken = IOption(optionAddress);\r\n        uint256 liquidity_ = liquidity;\r\n        uint256 deadline_ = deadline;\r\n        uint256 amountAMin_ = amountAMin;\r\n        uint256 amountBMin_ = amountBMin;\r\n        {\r\n            uint8 v_ = v;\r\n            bytes32 r_ = r;\r\n            bytes32 s_ = s;\r\n            (IUniswapV2Pair pair, , ) = getOptionPair(optionToken);\r\n            pair.permit(\r\n                getCaller(),\r\n                address(_primitiveRouter),\r\n                liquidity_,\r\n                deadline_,\r\n                v_,\r\n                r_,\r\n                s_\r\n            );\r\n        }\r\n        return\r\n            removeShortLiquidityThenCloseOptions(\r\n                address(optionToken),\r\n                liquidity_,\r\n                amountAMin_,\r\n                amountBMin_\r\n            );\r\n    }\r\n\r\n    struct RemoveAmounts {\r\n        uint256 liquidity;\r\n        uint256 amountAMin;\r\n        uint256 amountBMin;\r\n    }\r\n\r\n    /**\r\n     * @notice  Calls `UniswapV2Pair.burn(address(this))` to burn LP tokens for pair tokens.\r\n     * @param   pair The UniswapV2Pair contract to burn LP tokens of.\r\n     * @param   tokenA The first token of the pair.\r\n     * @param   tokenB The second token of the pair.\r\n     * @param   params The amounts to specify the amount to remove and minAmounts to withdraw.\r\n     * @return  Returns (amountTokenA, amountTokenB) which is (redeem, underlying) amounts.\r\n     */\r\n    function _removeLiquidity(\r\n        IUniswapV2Pair pair,\r\n        address tokenA,\r\n        address tokenB,\r\n        RemoveAmounts memory params\r\n    ) internal returns (uint256, uint256) {\r\n        (uint256 amount0, uint256 amount1) = pair.burn(address(this));\r\n        (address token0, ) = CoreLib.sortTokens(tokenA, tokenB);\r\n        (uint256 amountA, uint256 amountB) =\r\n            tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= params.amountAMin, \"PrimitiveLiquidity: INSUFFICIENT_A\");\r\n        require(amountB >= params.amountBMin, \"PrimitiveLiquidity: INSUFFICIENT_B\");\r\n        return (amountA, amountB);\r\n    }\r\n\r\n    // ===== View =====\r\n\r\n    /**\r\n     * @notice  Gets the UniswapV2Router02 contract address.\r\n     */\r\n    function getRouter() public view override returns (IUniswapV2Router02) {\r\n        return _router;\r\n    }\r\n\r\n    /**\r\n     * @notice  Gets the UniswapV2Factory contract address.\r\n     */\r\n    function getFactory() public view override returns (IUniswapV2Factory) {\r\n        return _factory;\r\n    }\r\n\r\n    /**\r\n     * @notice  Fetchs the Uniswap Pair for an option's redeemToken and underlyingToken params.\r\n     * @param   option The option token to get the corresponding UniswapV2Pair market.\r\n     * @return  The pair address, as well as the tokens of the pair.\r\n     */\r\n    function getOptionPair(IOption option)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            IUniswapV2Pair,\r\n            address,\r\n            address\r\n        )\r\n    {\r\n        address redeem = option.redeemToken();\r\n        address underlying = option.getUnderlyingTokenAddress();\r\n        IUniswapV2Pair pair = IUniswapV2Pair(_factory.getPair(redeem, underlying));\r\n        return (pair, underlying, redeem);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IPrimitiveLiquidity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {\r\n    IUniswapV2Router02\r\n} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport {\r\n    IUniswapV2Factory\r\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\r\nimport {IUniswapV2Pair} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\nimport {IOption} from \"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\";\r\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\r\n\r\ninterface IPrimitiveLiquidity {\r\n    // ==== External ====\r\n\r\n    function addShortLiquidityWithUnderlying(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function addShortLiquidityWithETH(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function addShortLiquidityWithUnderlyingWithPermit(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function addShortLiquidityDAIWithPermit(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function removeShortLiquidityThenCloseOptions(\r\n        address optionAddress,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin\r\n    ) external returns (uint256);\r\n\r\n    function removeShortLiquidityThenCloseOptionsWithPermit(\r\n        address optionAddress,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256);\r\n\r\n    // ==== View ====\r\n\r\n    function getRouter() external view returns (IUniswapV2Router02);\r\n\r\n    function getFactory() external view returns (IUniswapV2Factory);\r\n\r\n    function getOptionPair(IOption option)\r\n        external\r\n        view\r\n        returns (\r\n            IUniswapV2Pair,\r\n            address,\r\n            address\r\n        );\r\n}\r\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   TestERC20\r\n * @author  Primitive\r\n * @notice  An opinionated ERC20 with `permit` to use ONLY for testing.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\nimport {IERC20Permit} from \"../interfaces/IERC20Permit.sol\";\r\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\ncontract TestERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public name = \"Test Token\";\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint256 initialSupply\r\n    ) public {\r\n        name = name_;\r\n        symbol = symbol_;\r\n        _mint(msg.sender, initialSupply);\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                ),\r\n                keccak256(bytes(name_)),\r\n                keccak256(bytes(\"1\")),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param value The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address to, uint256 value) public returns (bool) {\r\n        _mint(to, value);\r\n        return true;\r\n    }\r\n\r\n    function _mint(address to, uint256 value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint256 value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint256 value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool) {\r\n        if (allowance[from][msg.sender] != uint256(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"Primitive: EXPIRED\");\r\n        bytes32 digest =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR,\r\n                    keccak256(\r\n                        abi.encode(\r\n                            PERMIT_TYPEHASH,\r\n                            owner,\r\n                            spender,\r\n                            value,\r\n                            nonces[owner]++,\r\n                            deadline\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(\r\n            recoveredAddress != address(0) && recoveredAddress == owner,\r\n            \"Primitive: INVALID_SIGNATURE\"\r\n        );\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/PrimitiveRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Router\r\n * @author  Primitive\r\n * @notice  Contract to execute Primitive Connector functions.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport {\r\n    IPrimitiveRouter,\r\n    IRegistry,\r\n    IOption,\r\n    IERC20,\r\n    IWETH\r\n} from \"./interfaces/IPrimitiveRouter.sol\";\r\n\r\n/**\r\n * @notice  Used to execute calls on behalf of the Router contract.\r\n * @dev     Changes `msg.sender` context so the Router is not `msg.sender`.\r\n */\r\ncontract Route {\r\n    function executeCall(address target, bytes calldata params) external payable {\r\n        (bool success, bytes memory returnData) = target.call.value(msg.value)(params);\r\n        require(success, \"Route: EXECUTION_FAIL\");\r\n    }\r\n}\r\n\r\ncontract PrimitiveRouter is IPrimitiveRouter, Ownable, Pausable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data.\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows.\r\n\r\n    // Constants\r\n    address private constant _NO_CALLER = address(0x0); // Default state for `_CALLER`.\r\n\r\n    // Events\r\n    event Initialized(address indexed from); // Emmitted on deployment\r\n    event Executed(address indexed from, address indexed to, bytes params);\r\n    event RegisteredOptions(address[] indexed options);\r\n    event RegisteredConnectors(address[] indexed connectors, bool[] registered);\r\n\r\n    // State variables\r\n    IRegistry private _registry; // The Primitive Registry which deploys Option clones.\r\n    IWETH private _weth; // Canonical WETH9\r\n    Route private _route; // Intermediary to do connector.call() from.\r\n    address private _CONNECTOR = _NO_CALLER; // If _EXECUTING, the `connector` of the execute call param.\r\n    address private _CALLER = _NO_CALLER; // If _EXECUTING, the orginal `_msgSender()` of the execute call.\r\n    bool private _EXECUTING; // True if the `executeCall` function was called.\r\n\r\n    // Whitelisted mappings\r\n    mapping(address => bool) private _registeredConnectors;\r\n    mapping(address => bool) private _registeredOptions;\r\n\r\n    /**\r\n     * @notice  A mutex to use during an `execute` call.\r\n     * @dev     Checks to make sure the `_CONNECTOR` in state is the `msg.sender`.\r\n     *          Checks to make sure a `_CALLER` was set.\r\n     *          Fails if this modifier is triggered by an external call.\r\n     *          Fails if this modifier is triggered by calling a function without going through `executeCall`.\r\n     */\r\n    modifier isExec() {\r\n        require(_CONNECTOR == _msgSender(), \"Router: NOT_CONNECTOR\");\r\n        require(_CALLER != _NO_CALLER, \"Router: NO_CALLER\");\r\n        require(!_EXECUTING, \"Router: IN_EXECUTION\");\r\n        _EXECUTING = true;\r\n        _;\r\n        _EXECUTING = false;\r\n    }\r\n\r\n    // ===== Constructor =====\r\n\r\n    constructor(address weth_, address registry_) public {\r\n        require(address(_weth) == address(0x0), \"Router: INITIALIZED\");\r\n        _route = new Route();\r\n        _weth = IWETH(weth_);\r\n        _registry = IRegistry(registry_);\r\n        emit Initialized(_msgSender());\r\n    }\r\n\r\n    // ===== Pausability =====\r\n\r\n    /**\r\n     * @notice  Halts use of `executeCall`, and other functions that change state.\r\n     */\r\n    function halt() external override onlyOwner {\r\n        if (paused()) {\r\n            _unpause();\r\n        } else {\r\n            _pause();\r\n        }\r\n    }\r\n\r\n    // ===== Registration =====\r\n\r\n    /**\r\n     * @notice  Checks option against Primitive Registry. If from Registry, registers as true.\r\n     *          NOTE: Purposefully does not have `onlyOwner` modifier.\r\n     * @dev     Sets `optionAddresses` to true in the whitelisted options mapping, if from Registry.\r\n     * @param   optionAddresses The array of option addresses to update.\r\n     */\r\n    function setRegisteredOptions(address[] calldata optionAddresses)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        uint256 len = optionAddresses.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            address option = optionAddresses[i];\r\n            require(isFromPrimitiveRegistry(IOption(option)), \"Router: EVIL_OPTION\");\r\n            _registeredOptions[option] = true;\r\n        }\r\n        emit RegisteredOptions(optionAddresses);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Allows the `owner` to set whitelisted connector contracts.\r\n     * @dev     Sets `connectors` to `isValid` in the whitelisted connectors mapping.\r\n     * @param   connectors The array of option addresses to update.\r\n     * @param   isValid Whether or not the optionAddress is registered.\r\n     */\r\n    function setRegisteredConnectors(address[] memory connectors, bool[] memory isValid)\r\n        public\r\n        override\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        uint256 len = connectors.length;\r\n        require(len == isValid.length, \"Router: LENGTHS\");\r\n        for (uint256 i = 0; i < len; i++) {\r\n            address connector = connectors[i];\r\n            bool status = isValid[i];\r\n            _registeredConnectors[connector] = status;\r\n        }\r\n        emit RegisteredConnectors(connectors, isValid);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Checks an option against the Primitive Registry.\r\n     * @param   option The IOption token to check.\r\n     * @return  Whether or not the option was deployed from the Primitive Registry.\r\n     */\r\n    function isFromPrimitiveRegistry(IOption option) internal view returns (bool) {\r\n        return (address(option) ==\r\n            _registry.getOptionAddress(\r\n                option.getUnderlyingTokenAddress(),\r\n                option.getStrikeTokenAddress(),\r\n                option.getBaseValue(),\r\n                option.getQuoteValue(),\r\n                option.getExpiryTime()\r\n            ) &&\r\n            address(option) != address(0));\r\n    }\r\n\r\n    // ===== Operations =====\r\n\r\n    /**\r\n     * @notice  Transfers ERC20 tokens from the executing `_CALLER` to the executing `_CONNECTOR`.\r\n     * @param   token The address of the ERC20.\r\n     * @param   amount The amount of ERC20 to transfer.\r\n     * @return  Whether or not the transfer succeeded.\r\n     */\r\n    function transferFromCaller(address token, uint256 amount)\r\n        public\r\n        override\r\n        isExec\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        IERC20(token).safeTransferFrom(\r\n            getCaller(), // Account to pull from\r\n            _msgSender(), // The connector\r\n            amount\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Transfers ERC20 tokens from the executing `_CALLER` to an arbitrary address.\r\n     * @param   token The address of the ERC20.\r\n     * @param   amount The amount of ERC20 to transfer.\r\n     * @return  Whether or not the transfer succeeded.\r\n     */\r\n    function transferFromCallerToReceiver(\r\n        address token,\r\n        uint256 amount,\r\n        address receiver\r\n    ) public override isExec whenNotPaused returns (bool) {\r\n        IERC20(token).safeTransferFrom(\r\n            getCaller(), // Account to pull from\r\n            receiver,\r\n            amount\r\n        );\r\n        return true;\r\n    }\r\n\r\n    // ===== Execute =====\r\n\r\n    /**\r\n     * @notice  Executes a call with `params` to the target `connector` contract from `_route`.\r\n     * @param   connector The Primitive Connector module to call.\r\n     * @param   params The encoded function data to use.\r\n     */\r\n    function executeCall(address connector, bytes calldata params)\r\n        external\r\n        payable\r\n        override\r\n        whenNotPaused\r\n    {\r\n        require(_registeredConnectors[connector], \"Router: INVALID_CONNECTOR\");\r\n        _CALLER = _msgSender();\r\n        _CONNECTOR = connector;\r\n        _route.executeCall.value(msg.value)(connector, params);\r\n        _CALLER = _NO_CALLER;\r\n        _CONNECTOR = _NO_CALLER;\r\n        emit Executed(_msgSender(), connector, params);\r\n    }\r\n\r\n    // ===== Fallback =====\r\n\r\n    receive() external payable whenNotPaused {\r\n        assert(_msgSender() == address(_weth)); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // ===== View =====\r\n\r\n    /**\r\n     * @notice  Returns the IWETH contract address.\r\n     */\r\n    function getWeth() public view override returns (IWETH) {\r\n        return _weth;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the Route contract which executes functions on behalf of this contract.\r\n     */\r\n    function getRoute() public view override returns (address) {\r\n        return address(_route);\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the `_CALLER` which is set to `_msgSender()` during an `executeCall` invocation.\r\n     */\r\n    function getCaller() public view override returns (address) {\r\n        return _CALLER;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the Primitive Registry contract address.\r\n     */\r\n    function getRegistry() public view override returns (IRegistry) {\r\n        return _registry;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns a bool if `option` is registered or not.\r\n     * @param   option The address of the Option to check if registered.\r\n     */\r\n    function getRegisteredOption(address option) external view override returns (bool) {\r\n        return _registeredOptions[option];\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns a bool if `connector` is registered or not.\r\n     * @param   connector The address of the Connector contract to check if registered.\r\n     */\r\n    function getRegisteredConnector(address connector)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _registeredConnectors[connector];\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the NPM package version and github version of this contract.\r\n     * @dev     For the npm package: @primitivefi/v1-connectors\r\n     *          For the repository: github.com/primitivefinance/primitive-v1-connectors\r\n     * @return  The apiVersion string.\r\n     */\r\n    function apiVersion() public pure override returns (string memory) {\r\n        return \"2.0.0\";\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/interfaces/IPrimitiveCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {IOption} from \"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\";\r\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\r\n\r\ninterface IPrimitiveCore {\r\n    // ===== External =====\r\n\r\n    function safeMintWithETH(IOption optionToken)\r\n        external\r\n        payable\r\n        returns (uint256, uint256);\r\n\r\n    function safeMintWithPermit(\r\n        IOption optionToken,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256, uint256);\r\n\r\n    function safeExerciseWithETH(IOption optionToken)\r\n        external\r\n        payable\r\n        returns (uint256, uint256);\r\n\r\n    function safeExerciseForETH(IOption optionToken, uint256 exerciseQuantity)\r\n        external\r\n        returns (uint256, uint256);\r\n\r\n    function safeRedeemForETH(IOption optionToken, uint256 redeemQuantity)\r\n        external\r\n        returns (uint256);\r\n\r\n    function safeCloseForETH(IOption optionToken, uint256 closeQuantity)\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n"
    },
    "contracts/connectors/PrimitiveCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Core\r\n * @author  Primitive\r\n * @notice  A Connector with Ether abstractions for Primitive Option tokens.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n// Primitive\r\nimport {CoreLib, SafeMath} from \"../libraries/CoreLib.sol\";\r\nimport {IPrimitiveCore, IERC20Permit, IOption} from \"../interfaces/IPrimitiveCore.sol\";\r\nimport {PrimitiveConnector} from \"./PrimitiveConnector.sol\";\r\n\r\ncontract PrimitiveCore is PrimitiveConnector, IPrimitiveCore, ReentrancyGuard {\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    event Initialized(address indexed from); // Emmitted on deployment\r\n    event Minted(\r\n        address indexed from,\r\n        address indexed option,\r\n        uint256 longQuantity,\r\n        uint256 shortQuantity\r\n    );\r\n    event Exercised(address indexed from, address indexed option, uint256 quantity);\r\n    event Redeemed(address indexed from, address indexed option, uint256 quantity);\r\n    event Closed(address indexed from, address indexed option, uint256 quantity);\r\n\r\n    // ===== Constructor =====\r\n\r\n    constructor(address weth_, address primitiveRouter_)\r\n        public\r\n        PrimitiveConnector(weth_, primitiveRouter_)\r\n    {\r\n        emit Initialized(_msgSender());\r\n    }\r\n\r\n    // ===== Weth Abstraction =====\r\n\r\n    /**\r\n     * @dev     Mints msg.value quantity of options and \"quote\" (option parameter) quantity of redeem tokens.\r\n     * @notice  This function is for options that have WETH as the underlying asset.\r\n     * @param   optionToken The address of the option token to mint.\r\n     * @return  (uint, uint) Returns the (long, short) option tokens minted\r\n     */\r\n    function safeMintWithETH(IOption optionToken)\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256, uint256)\r\n    {\r\n        require(msg.value > 0, \"PrimitiveCore: ERR_ZERO\");\r\n        address caller = getCaller();\r\n        _depositETH(); // Deposits `msg.value` to Weth contract.\r\n        (uint256 long, uint256 short) = _mintOptionsToReceiver(optionToken, caller);\r\n        emit Minted(caller, address(optionToken), long, short);\r\n        return (long, short);\r\n    }\r\n\r\n    /**\r\n     * @dev     Mints \"amount\" quantity of options and \"quote\" (option parameter) quantity of redeem tokens.\r\n     * @notice  This function is for options that have an EIP2612 (permit) enabled token as the underlying asset.\r\n     * @param   optionToken The address of the option token to mint.\r\n     * @param   amount The quantity of options to mint.\r\n     * @param   deadline The timestamp which expires the `permit` call.\r\n     * @return  (uint, uint) Returns the (long, short) option tokens minted\r\n     */\r\n    function safeMintWithPermit(\r\n        IOption optionToken,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256, uint256)\r\n    {\r\n        // Permit minting using the caller's underlying tokens.\r\n        IERC20Permit(optionToken.getUnderlyingTokenAddress()).permit(\r\n            getCaller(),\r\n            address(_primitiveRouter),\r\n            amount,\r\n            deadline,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n        (uint256 long, uint256 short) = _mintOptionsFromCaller(optionToken, amount);\r\n        emit Minted(getCaller(), address(optionToken), long, short);\r\n        return (long, short);\r\n    }\r\n\r\n    /**\r\n     * @dev     Swaps msg.value of strikeTokens (ethers) to underlyingTokens.\r\n     *          Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\r\n     *          Msg.value (quote units) * base / quote = base units (underlyingTokens) to withdraw.\r\n     * @notice  This function is for options with WETH as the strike asset.\r\n     *          Burns option tokens, accepts ethers, and pushes out underlyingTokens.\r\n     * @param   optionToken The address of the option contract.\r\n     */\r\n    function safeExerciseWithETH(IOption optionToken)\r\n        public\r\n        payable\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256, uint256)\r\n    {\r\n        require(msg.value > 0, \"PrimitiveCore: ZERO\");\r\n\r\n        _depositETH(); // Deposits `msg.value` to Weth contract.\r\n\r\n        uint256 long = CoreLib.getProportionalLongOptions(optionToken, msg.value);\r\n        _transferFromCaller(address(optionToken), long); // Pull option tokens.\r\n\r\n        // Pushes option tokens and weth (strike asset), receives underlying tokens.\r\n        emit Exercised(getCaller(), address(optionToken), long);\r\n        return _exerciseOptions(optionToken, long);\r\n    }\r\n\r\n    /**\r\n     * @dev     Swaps strikeTokens to underlyingTokens, WETH, which is converted to ethers before withdrawn.\r\n     *          Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\r\n     * @notice  This function is for options with WETH as the underlying asset.\r\n     *          Burns option tokens, pulls strikeTokens, and pushes out ethers.\r\n     * @param   optionToken The address of the option contract.\r\n     * @param   exerciseQuantity Quantity of optionTokens to exercise.\r\n     */\r\n    function safeExerciseForETH(IOption optionToken, uint256 exerciseQuantity)\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256, uint256)\r\n    {\r\n        address underlying = optionToken.getUnderlyingTokenAddress();\r\n        address strike = optionToken.getStrikeTokenAddress();\r\n        uint256 strikeQuantity =\r\n            CoreLib.getProportionalShortOptions(optionToken, exerciseQuantity);\r\n        // Pull options and strike assets from `getCaller()` and send to option contract.\r\n        _transferFromCallerToReceiver(\r\n            address(optionToken),\r\n            exerciseQuantity,\r\n            address(optionToken)\r\n        );\r\n        _transferFromCallerToReceiver(strike, strikeQuantity, address(optionToken));\r\n\r\n        // Release underlying tokens by invoking `exerciseOptions()`\r\n        (uint256 strikesPaid, uint256 options) =\r\n            optionToken.exerciseOptions(address(this), exerciseQuantity, new bytes(0));\r\n        _withdrawETH(); // Unwraps this contract's balance of Weth and sends to `getCaller()`.\r\n        emit Exercised(getCaller(), address(optionToken), exerciseQuantity);\r\n        return (strikesPaid, options);\r\n    }\r\n\r\n    /**\r\n     * @dev     Burns redeem tokens to withdraw strike tokens (ethers) at a 1:1 ratio.\r\n     * @notice  This function is for options that have WETH as the strike asset.\r\n     *          Converts WETH to ethers, and withdraws ethers to the receiver address.\r\n     * @param   optionToken The address of the option contract.\r\n     * @param   redeemQuantity The quantity of redeemTokens to burn.\r\n     */\r\n    function safeRedeemForETH(IOption optionToken, uint256 redeemQuantity)\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256)\r\n    {\r\n        // Require the strike token to be Weth.\r\n        address redeem = optionToken.redeemToken();\r\n        // Pull redeem tokens from `getCaller()` and send to option contract.\r\n        _transferFromCallerToReceiver(redeem, redeemQuantity, address(optionToken));\r\n        uint256 short = optionToken.redeemStrikeTokens(address(this));\r\n        _withdrawETH(); // Unwraps this contract's balance of Weth and sends to `getCaller()`.\r\n        emit Redeemed(getCaller(), address(optionToken), redeemQuantity);\r\n        return short;\r\n    }\r\n\r\n    /**\r\n     * @dev Burn optionTokens and redeemTokens to withdraw underlyingTokens (ethers).\r\n     * @notice This function is for options with WETH as the underlying asset.\r\n     * WETH underlyingTokens are converted to ethers before being sent to receiver.\r\n     * The redeemTokens to burn is equal to the optionTokens * strike ratio.\r\n     * inputOptions = inputRedeems / strike ratio = outUnderlyings\r\n     * @param optionToken The address of the option contract.\r\n     * @param closeQuantity Quantity of optionTokens to burn and an input to calculate how many redeems to burn.\r\n     */\r\n    function safeCloseForETH(IOption optionToken, uint256 closeQuantity)\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        address redeem = optionToken.redeemToken();\r\n        uint256 short = CoreLib.getProportionalShortOptions(optionToken, closeQuantity);\r\n        // Pull redeem tokens from `getCaller()` and send to option contract.\r\n        _transferFromCallerToReceiver(redeem, short, address(optionToken));\r\n        // Pull options if not expired, and send to option contract.\r\n        if (optionToken.getExpiryTime() >= now) {\r\n            _transferFromCallerToReceiver(\r\n                address(optionToken),\r\n                closeQuantity,\r\n                address(optionToken)\r\n            );\r\n        }\r\n        // Release underlyingTokens by invoking `closeOptions()`\r\n        (uint256 inputRedeems, uint256 inputOptions, uint256 outUnderlyings) =\r\n            optionToken.closeOptions(address(this));\r\n\r\n        _withdrawETH(); // Unwraps this contract's balance of Weth and sends to `getCaller()`.\r\n        emit Closed(getCaller(), address(optionToken), closeQuantity);\r\n        return (inputRedeems, inputOptions, outUnderlyings);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}